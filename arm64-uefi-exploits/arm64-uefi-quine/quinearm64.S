// quinearm64.S arm64 assembly source code
// QuineArm64 is a self-replicating UEFI app, written in arm64 assembly
// by ic3qu33n


.text
.globl _start
.globl UefiMain
.align 4

// Registers (initial program state)
//	x0: Image Handle
//	x1: System Table
//	x30: return address
//
//	Reference of EFI function calls (from C source):
//	status= gBS->HandleProtocol(
//		ImageHandle,
//		&lip_guid,
//		(void**)&loadedimageprotocol)
//		status= gBS->HandleProtocol(
//			devicehandle,
//			&sfsp_guid,
//			(void**)&sfsp,
//			ImageHandle)
//		EFI_FILE_PROTOCOL *rootvolume;
//		status = sfsp->OpenVolume(sfsp, &rootvolume);
//		if (status == EFI_SUCCESS) {
//			EFI_FILE_PROTOCOL *hostfile = NULL;
//			EFI_FILE_PROTOCOL *targetfile = NULL;
//			UINT64 host_attribs = 0x0000000000000000;
//			//set buffer size (destination file img_size) == original img_size	
//			UINTN newfile_buffersize =(UINTN) img_size;
//			VOID *temp_buf;
//			status = rootvolume->Open(rootvolume, &hostfile, L"\\UEFISelfRep.efi",0x0000000000000001, host_attribs);
//			if (status == EFI_SUCCESS){
//				status = gBS->AllocatePool(
//					AllocateAnyPages,
//					newfile_buffersize,
//					(void**)&temp_buf); 
//				status=hostfile->Read(hostfile, &newfile_buffersize, temp_buf);
//				status=hostfile->Read(hostfile, &newfile_buffersize, temp_buf);
//				status  = rootvolume->Open(rootvolume, &targetfile, L"\\4.efi", EFI_FILE_MODE_READ |  EFI_FILE_MODE_WRITE | EFI_FILE_MODE_CREATE, 0);
//				status=targetfile->Write(targetfile, &newfile_buffersize, temp_buf);
//				status=targetfile->Close(targetfile);
//				gBS->FreePool(temp_buf);
//				status=hostfile->Close(hostfile);
//				rootvolume->Close(rootvolume);
//			} else {
//				return status;
//			}
//		} else {
//			return status;
//		}
//	}
//	return status;		
//
//	GUIDS:
//	#define EFI_LOADED_IMAGE_PROTOCOL_GUID {0x5B1B31A1,0x9562,0x11d2,{0x8E,0x3F,0x00,0xA0,0xC9,0x69,0x72,0x3B}}
//	#define EFI_SIMPLE_FILE_SYSTEM_PROTOCOL_GUID {0x0964e5b22,0x6459,0x11d2,{0x8e,0x39,0x00,0xa0,0xc9,0x69,0x72,0x3b}}  
//
//
//
// Note: yes, the stack frame is larger than necessary since I optimized out 
// certain vars during the dev process and didn't end up needing the entire frame
// Currently, yeah there are gaps in the stack frame, but
// decreasing the stack frame size requires shuffling things around slightly.
// shrinking down the stack frame is part of future arm64 asm golf plans
// until then, enjoy this nice stack frame diagram I made 4 u.
// you're welcome
//
//Stack frame:
// 	[sp]			fp (x29)
//	[sp, 0x8] 		lr (x30)	
//	[sp, 0x10] 		x1 (gST)
//	[sp, 0x18] 		x0 (ImageHandle)
//	[sp, 0x20] 		x19
//	[sp, 0x28] 		x20
//	[sp, 0x30] 
//	[sp, 0x38] 		EFI_SIMPLE_FILESYSTEM_PROTOCOL* sfsp
//	[sp, 0x40] 		LIP_GUID[0]
//	[sp, 0x44] 		LIP_GUID[1]
//	[sp, 0x46] 		LIP_GUID[2]
//	[sp, 0x48] 		LIP_GUID[3]
//	[sp, 0x50] 		SFSP_GUID[0]
//	[sp, 0x54] 		SFSP_GUID[1]
//	[sp, 0x56] 		SFSP_GUID[2]
//	[sp, 0x58] 		SFSP_GUID[3]
//	[sp, 0x60]		EFI_LOADED_IMAGE_PROTOCOL* lip
//	[sp, 0x68]		UINT64 img_size (== lip->ImageSize) 
//	[sp, 0x70]		EFI_HANDLE devicehandle (== lip->DeviceHandle)
//	[sp, 0x78]		UINT64 host_attributes;
//	[sp, 0x80] 		EFI_FILE_PROTOCOL* rootVolume
//	[sp, 0x88] 		EFI_FILE_PROTOCOL* hostFile
//	[sp, 0x90] 		EFI_FILE_PROTOCOL* targetFile
//	[sp, 0x98] 		UINTN newfile_buffersize
//	[sp, 0xa0]		gBS
//	[sp, 0xa8]		status
//	[sp, 0xb0]		VOID * tmp_buffer
//	[sp, 0xb8]
//	[sp, 0xc0]


_start:
	b UefiMain

UefiMain:
	//function prologue
	stp	x29, x30, [sp, #-0xc0]!
	mov	x29, sp					// Defining local vars+storing them on the stack 
	stp	x19, x20, [sp, #0x20]
	
	str	x0, [sp, #0x18] 		// store imageHandle var on stack
	str	x1, [sp, #0x10] 		// store efiSystemTable var on stack
	ldr x0, [sp, #0x10] 		// load efiSystemTable into x0
	ldr x0, [x0, #0x60] 		// load x0 =SystemTable + 0x60 == gBS
	str x0, [sp, #0xa0]			// store gBS var on stack
	str xzr, [sp, #0x60] 		// store LoadedImageProtocol* lip=NULL on stack
	str xzr, [sp, #0x68]		// store lip->ImageSize = 0 on stack
	str xzr, [sp, #0x70] 		// store lip->DeviceHandle=NULL on stack
	str xzr, [sp, #0x80] 		// store rootvolume=NULL on stack
	str xzr, [sp, #0x88] 		// store hostfile=NULL on stack
	str xzr, [sp, #0x90] 		// store targetfile=NULL on stack
	str xzr, [sp, #0xb0] 		// store tmp_buffer=NULL on stack

	//load Loaded Image Protocol guid
	mov w0, #0x31a1
	movk w0, #0x5b1b, LSL #16
	str w0, [sp,#0x40]		// store final part of LIP GUID at sp-0x40	
	mov w0, #0x9562
	strh w0, [sp, #0x44]		// store 2nd part of LIP GUID at sp-0x44	
	mov w0, #0x11d2
	strh w0, [sp, #0x46]		// store 3rd part of LIP GUID at sp-0x46	
	mov x0, #0x3f8e
	movk x0, #0xa000, LSL #16
	movk x0, #0x69c9, LSL #32
	movk x0, #0x3b72, LSL #48
	str x0, [sp, #0x48]		// store final part of LIP GUID at sp-0x48	
	add x0, sp, #0x40		// move address of sp+40 to x0
	mov x1, x0		// address of $sp+0x40 (LIP GUID) into x1
	
	ldr x0, [sp, #0xa0]		// load x0 = gBS
	ldr x6, [x0, #0x98]		// load gBS+0x98 (HandleProtocol) into x6
	ldr x3, [sp, #0x18]		// load ImageHandle from stack into x3 
	add x0, sp, #0x60		// move address of $sp+0x60 into x0
	mov x2, x0		// addr of $sp+0x60 (loadedImageProtocol*) into x2
	
	ldr x0, [sp, #0x18] 	// load ImageHandle from stack into x0 
	blr x6
	cmp x0, 0x0				// check if EFI_STATUS==EFI_SUCCESS (0x0)
	b.ne Print

store_loadedimage_data:
	ldr	x0, [sp, #0x60]
	ldr x0, [x0, #0x18]		// deviceHandle = loadedImageProtocol->deviceHandle
	str x0, [sp, #0x70]		// store deviceHandle at [sp+ 0x70]
	ldr x0, [sp, #0x60]
	ldr x0, [x0, #0x48]		// imgSize = loadedImageProtocol->imageSize
	str	x0, [sp, #0x68]		// store imgSize at [sp+ 0x68] 


get_sfsp:	
	//load Simple Filesystem Protocol guid
	mov w0, #0x5b22
	movk w0, #0x964e, LSL #16
	str w0, [sp,#0x50]  		//Store first part of SFSP GUID at sp-0x50	
	mov w0, #0x6459
	strh w0, [sp, #0x54] 		//Store 2nd part of SFSP GUID at sp-0x54	
	mov w0, #0x11d2
	strh w0, [sp, #0x56] 		//Store 3rd part of SFSP GUID at sp-0x56	
	mov x0, #0x398e
	movk x0, #0xa000, LSL #16
	movk x0, #0x69c9, LSL #32
	movk x0, #0x3b72, LSL #48
	str x0, [sp, #0x58] 		// Store final part of SFSP GUID at sp-0x58	
	add x0, sp, #0x50			// move address of sp+50 to x0
	mov x1, x0					// address of $sp+0x50 (SFSP GUID) into x1
	ldr x0, [sp, #0xa0] 		// load x0 = gBS
	ldr x6, [x0, #0x98] 		// load gBS+0x98 (HandleProtocol) into x6
	ldr x3, [sp, #0x18]  		// load ImageHandle from stack into x3 
	add x0, sp, #0x38			// move address of $sp+0x38 (sfsp) into x0
	mov x2, x0					// addr of $sp+0x38 (sfsp) into x2
	ldr x0, [sp, #0x70] //load DeviceHandle from stack into x0 
	blr x6
	cmp x0, 0x0			//check if EFI_STATUS==EFI_SUCCESS (0x0)
	b.ne Print
	
get_root_volume:
	ldr x0, [sp, #0x38]			// load sfsp into x0
	ldr x6, [x0, #0x8]			// load sfsp+0x8 (sfsp->OpenVolume()) into x6
	add x2, sp, #0x80			// move address of $sp+0x80 (rootVolume) into x2
	mov x1, x2					// addr of $sp+0x80 (rootvolume) into x2
	blr x6
	cmp x0, 0x0					//check if EFI_STATUS==EFI_SUCCESS (0x0)
	b.ne Print

open_host_file:
	ldr x0, [sp, #0x80]			// load EFI_FILE_PROTOCOL* rootvolume into x0
	ldr x6, [x0, #0x8]			// load rootvolume+0x8 (rootvolume->OpenFile()) into x6
	add x2, sp, #0x88			// move address of $sp+0x88 (hostfile) into x2
	mov x1, x2					// addr of $sp+0x88 (hostfile) into x1
	adrp x2, hostfilename
	add x2, x2, :lo12: hostfilename	//load address of hostfilename into x2	
	mov x3, #0x1
	blr x6
	cmp x0, 0x0					// check if EFI_STATUS==EFI_SUCCESS (0x0)
	b.ne Print

open_target_file:
	ldr x0, [sp, #0x80]			// load EFI_FILE_PROTOCOL* rootvolume into x0
	ldr x6, [x0, #0x8]			// load rootvolume+0x8 (rootvolume->OpenFile()) into x6
	add x2, sp, #0x90			// move address of $sp+0x90 (targetfile) into x2
	mov x1, x2					// addr of $sp+0x90 (targetfile) into x1
	adrp x2, targetfilename
	add x2, x2, :lo12: targetfilename	//load address of hostfilename into x2	
	mov x3, #0x8000000000000003
	mov x4, #0x0
	blr x6
	cmp x0, 0x0					//check if EFI_STATUS==EFI_SUCCESS (0x0)
	b.ne Print
	
allocate_tmp_buffer:
	ldr x0, [sp, #0xa0]		// load x0 = gBS
	ldr x6, [x0, #0x40]		// load gBS+0x40 (AllocatePool) into x6
	ldr x1, [sp, #0x68]		// load imagesize into x1
	add x0, sp, #0xb0		// move address of $sp+0xb0 (temp_buffer) into x0
	mov x2, x0		// addr of $sp+0xb0 (temp_buffer) into x2
	mov x0, #0x0		// mov EFI_ALLOCATEPOOL_ALLOCATE_ANY_PAGES (0x0) into x0
	blr x6
	cmp x0, 0x0		//check if EFI_STATUS==EFI_SUCCESS (0x0)
	b.ne Print

read_host_file:
	ldr x0, [sp, #0x88]		// load EFI_FILE_PROTOCOL* hostfile into x0
	ldr x6, [x0, #0x20]		// load hostfile+0x20 (hostfile->ReadFile()) into x6
	add x2, sp, #0x68		// move address of $sp+0x68 (imagesize) into x2
	mov x1, x2		// addr of $sp+0x68 (imagesize) into x1
	ldr x2, [sp, #0xb0]		// load temp_buffer into x1
	blr x6
	cmp x0, 0x0		// check if EFI_STATUS==EFI_SUCCESS (0x0)
	b.ne Print

write_target_file:
	ldr x0, [sp, #0x90]		// load EFI_FILE_PROTOCOL* targetfile into x0
	ldr x6, [x0, #0x28]		// load targetfile+0x28 (targetfile->WriteFile()) into x6
	add x2, sp, #0x68		// move address of $sp+0x68 (imagesize) into x2
	mov x1, x2		// addr of $sp+0x68 (imagesize) into x1
	ldr x2, [sp, #0xb0]		// load temp_buffer into x1
	blr x6
	cmp x0, 0x0		// check if EFI_STATUS==EFI_SUCCESS (0x0)
	b.ne Print
	b close_targetfile

close_targetfile:
	ldr x0, [sp, #0x90]		// load EFI_FILE_PROTOCOL* targetfile into x0
	ldr x6, [x0, #0x10]		// load targetfile+0x10 (targetfile->CloseFile()) into x6
	blr x6
	cmp x0, 0x0		// check if EFI_STATUS==EFI_SUCCESS (0x0)
	b.ne Print
	
free_tmp_buffer:
	ldr x0, [sp, #0xa0]		// load x0 = gBS
	ldr x6, [x0, #0x48]		// load gBS+0x48 (FreePool) into x6
	ldr x0, [sp, #0xb0]		// move $sp+0xb0 (temp_buffer) into x0
	blr x6
	cmp x0, 0x0			//check if EFI_STATUS==EFI_SUCCESS (0x0)
	b.ne Print
	
close_hostfile:
	ldr x0, [sp, #0x88]		// load EFI_FILE_PROTOCOL* hostfile into x0
	ldr x6, [x0, #0x10]		// load targetfile+0x10 (targetfile->CloseFile()) into x6
	blr x6
	cmp x0, 0x0		// check if EFI_STATUS==EFI_SUCCESS (0x0)
	b.ne Print

close_rootvolume:
	ldr x0, [sp, #0x80]		// load EFI_FILE_PROTOCOL* rootvolume into x0
	ldr x6, [x0, #0x10]		// load targetfile+0x10 (targetfile->CloseFile()) into x6
	blr x6
	cmp x0, 0x0		// check if EFI_STATUS==EFI_SUCCESS (0x0)
	b.ne Print

baibai:
	ldr x1, [sp, #0x10]		// load x0 = SystemTable (from stack at sp - #0x10)
	ldr x0, [x1, #0x40]		// load x0 = ConOut (SystemTable + 0x40)
	ldr x3, [x0, #0x8]		// load x3 =  OutputString (SystemTable->ConOut->OutputString)
	ldr x0, [sp, #0x10]		// load x0 = SystemTable (from stack at sp + #0x10)
	ldr x2, [x0, #0x40]		// load x2 = ConOut == x0 + 0x40 = SystemTable + 0x40
	adrp x1, selfrepstr
	add x1, x1, :lo12: selfrepstr	
	mov x0, x2		// mov x0 = SystemTable->ConOut == x2
	blr x3		// call SystemTable->ConOut->OutputString(SystemTable->ConOut, L"Task of the translator complete\n");
	b exit

/*
//	Note: I used a very straightforward method in this print func for loading the string
//  There are other techniques for this. 
//  I've included my source code for one alternate method 
//	for moving a UEFI-compliant UTF16 string to the stack
//	which can be used for code golfing purposes 
//  (e.g. eliminate or minimize use of .data section) 
//	This method store the UTF16 string "Hell" on the stack
//  then prints it stdout
//	If you want a longer string, then just rinse and repeat
//  following the same process as was used for loading a GUID (detailed above)
//
//	ldr x1, [sp, #0x10]		
//	ldr x0, [x1, #0x40]		
//	ldr x3, [x0, #0x8]		
//	ldr x0, [sp, #0x10]		
//	ldr x2, [x0, #0x40]		
//	mov x1, #0x0048
//	movk x1, #0x0065, lsl #16
//	movk x1, #0x006c, lsl #32
//	movk x1, #0x006c, lsl #48
// 	str x1, [sp, #0x58]		;can be wherever on stack w enough space for length of str
//	add x1, sp, #0x58
//	mov x0, x2		// mov x0 = SystemTable->ConOut == x2
//	blr x3			
*/

Print:
	ldr x1, [sp, #0x10]		// load x0 = SystemTable (from stack at sp - #0x10)
	ldr x0, [x1, #0x40]		// load x0 = ConOut (SystemTable + 0x40)
	ldr x3, [x0, #0x8]		// load x3 = OutputString=SystemTable->ConOut->OutputString
	ldr x0, [sp, #0x10]		// load x0 = SystemTable (from stack at sp + #0x10)
	ldr x2, [x0, #0x40]		// load x2 = ConOut == x0 + 0x40 = SystemTable + 0x40
	adrp x1, hellostr
	add x1, x1, :lo12: hellostr//	
	mov x0, x2		// mov x0 = SystemTable->ConOut == x2
	blr x3			// call SystemTable->ConOut->OutputString(SystemTable->ConOut, L"hello from the other side\n");
	b exit
	
exit:
	//function epilogue
	mov x0, #0x0 				//return 0
	ldp x29, x30, [sp], #0xc0 	//restore x29 and x30
	ret	

.data
.balign 8
hellostr:
	.string16 "Hello from the other side... uh oh, something went wrong. Better start debugging... </3\r\n\0"
selfrepstr:
	.string16 "Task of the translator complete\r\nxoxo\r\nic3qu33n\r\n\r\n\0"

hostfilename:
	.string16 "\\QuineArm64.efi\0"

targetfilename:
	.string16 "\\4.efi\0"
