//UEFI quine written in aarch64 assembly
// by ic3qu33n


.text
.globl _start
.globl UefiMain
.align 4

// Registers (initial program state)
//	x0: Image Handle
//	x1: System Table
//	x30: return address
//
// OpenProtocol
//
//	status= gBS->OpenProtocol(
//		ImageHandle,
//		&lip_guid,
//		(void**)&loadedimageprotocol,
//		ImageHandle,
//		NULL,
//		EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL);
//		status= gBS->OpenProtocol(
//			devicehandle,
//			&sfsp_guid,
//			(void**)&sfsp,
//			ImageHandle,
//			NULL,
//			EFI_OPEN_PROTOCOL_BY_HANDLE_PROTOCOL);
//		EFI_FILE_PROTOCOL *rootvolume;
//		status = sfsp->OpenVolume(sfsp, &rootvolume);
//		if (status == EFI_SUCCESS) {
//			EFI_FILE_PROTOCOL *hostfile = NULL;
//			EFI_FILE_PROTOCOL *targetfile = NULL;
//			UINT64 host_attribs = 0x0000000000000000;
//			//set buffer size (destination file img_size) == original img_size	
//			UINTN newfile_buffersize =(UINTN) img_size;
//			VOID *temp_buf;
//			status = rootvolume->Open(rootvolume, &hostfile, L"\\UEFISelfRep.efi",0x0000000000000001, host_attribs);
//			if (status == EFI_SUCCESS){
//				status = gBS->AllocatePool(
//					AllocateAnyPages,
//					newfile_buffersize,
//					(void**)&temp_buf); 
//				status=hostfile->Read(hostfile, &newfile_buffersize, temp_buf);
//				status=hostfile->Read(hostfile, &newfile_buffersize, temp_buf);
//				status  = rootvolume->Open(rootvolume, &targetfile, L"\\4.efi", EFI_FILE_MODE_READ |  EFI_FILE_MODE_WRITE | EFI_FILE_MODE_CREATE, 0);
//				status=targetfile->Write(targetfile, &newfile_buffersize, temp_buf);
//				status=targetfile->Close(targetfile);
//				gBS->FreePool(temp_buf);
//				status=hostfile->Close(hostfile);
//				rootvolume->Close(rootvolume);
//			} else {
//				Print(L" hmm open root volum unsuccessful... something got effed.");
//			}
//		} else {
//			Print(L" hmm something got effed.");
//		}
//	}
//	return status;		
//
//
//	GUIDS:
//	#define EFI_LOADED_IMAGE_PROTOCOL_GUID {0x5B1B31A1,0x9562,0x11d2,{0x8E,0x3F,0x00,0xA0,0xC9,0x69,0x72,0x3B}}
//	#define EFI_SIMPLE_FILE_SYSTEM_PROTOCOL_GUID {0x0964e5b22,0x6459,0x11d2,{0x8e,0x39,0x00,0xa0,0xc9,0x69,0x72,0x3b}}  
//	******************************************************
//	EFI_HANDLE
//	******************************************************
//	typedef VOID *EFI_HANDLE;
//	
//	******************************************************
//	EFI_GUID
//	******************************************************
//	typedef struct {
//	   UINT32      Data1;
//	   UINT16      Data2;
//	   UINT16      Data3;
//	   UINT8       Data4[8];
//	} EFI_GUID;
//	need to reserve 128 bytes for GUID struct
//

//
//Stack frame:
// 	[sp]			fp (x29)
//	[sp, 0x8] 		lr (x30)	
//	[sp, 0x10] 		x1 (gST)
//	[sp, 0x18] 		x0 (ImageHandle)
//	[sp, 0x20] 		x19
//	[sp, 0x28] 		x20
//	[sp, 0x30] 
//	[sp, 0x38] 		EFI_SIMPLE_FILESYSTEM_PROTOCOL* sfsp
//	[sp, 0x40] 		LIP_GUID[0]
//	[sp, 0x44] 		LIP_GUID[1]
//	[sp, 0x46] 		LIP_GUID[2]
//	[sp, 0x48] 		LIP_GUID[3]
//	[sp, 0x50] 		SFSP_GUID[0]
//	[sp, 0x54] 		SFSP_GUID[1]
//	[sp, 0x56] 		SFSP_GUID[2]
//	[sp, 0x58] 		SFSP_GUID[3]
//	[sp, 0x60]		EFI_LOADED_IMAGE_PROTOCOL* lip
//	[sp, 0x68]		UINT64 img_size (== lip->ImageSize) 
//	[sp, 0x70]		EFI_HANDLE devicehandle (== lip->DeviceHandle)
//	[sp, 0x78]		UINT64 host_attributes;
//	[sp, 0x80] 		EFI_FILE_PROTOCOL* rootVolume
//	[sp, 0x88] 		EFI_FILE_PROTOCOL* hostFile
//	[sp, 0x90] 		EFI_FILE_PROTOCOL* targetFile
//	[sp, 0x98] 		UINTN newfile_buffersize
//	[sp, 0xa0]		gBS
//	[sp, 0xa8]		status
//	[sp, 0xb0]		VOID * tmp_buffer
//	[sp, 0xb8]
//	[sp, 0xc0]


_start:
	b UefiMain

UefiMain:
	//function prologue
	stp	x29, x30, [sp, #-0xc0]!
	//sub sp, sp, #0xa0
	mov	x29, sp			// Defining local vars+storing them on the stack 
	stp	x19, x20, [sp, #0x20]
	
	str	x0, [sp, #0x18] // Store imageHandle var on stack
	str	x1, [sp, #0x10] // Store efiSystemTable var on stack
	ldr x0, [sp, #0x10] //load efiSystemTable into x0
	ldr x0, [x0, #0x60] // load x0 =SystemTable + 0x60 == gBS
	str x0, [sp, #0xa0]	//store gBS var on stack
	str xzr, [sp, #0x60] //store LoadedImageProtocol* lip=NULL on stack
	str xzr, [sp, #0x68] // store lip->ImageSize = 0 on stack
	str xzr, [sp, #0x70] // store lip->DeviceHandle=NULL on stack
	str xzr, [sp, #0x80] // store rootvolume=NULL on stack
	str xzr, [sp, #0x88] // store hostfile=NULL on stack
	str xzr, [sp, #0x90] // store targetfile=NULL on stack
	str xzr, [sp, #0xb0] // store tmp_buffer=NULL on stack

	//load Loaded Image Protocol guid
	mov w0, #0x31a1
	movk w0, #0x5b1b, LSL #16
	str w0, [sp,#0x40]  //Store final part of LIP GUID at sp-0x40	
	mov w0, #0x9562
	strh w0, [sp, #0x44] //Store 2nd part of LIP GUID at sp-0x44	
	mov w0, #0x11d2
	strh w0, [sp, #0x46] //Store 3rd part of LIP GUID at sp-0x46	
	mov x0, #0x3f8e
	movk x0, #0xa000, LSL #16
	movk x0, #0x69c9, LSL #32
	movk x0, #0x3b72, LSL #48
	str x0, [sp, #0x48] //Store final part of LIP GUID at sp-0x48	

	add x0, sp, #0x40	//move address of sp+40 to x0
	mov x1, x0			//address of $sp+0x40 (LIP GUID) into x1
	
	ldr x0, [sp, #0xa0] //load x0 = gBS
	ldr x6, [x0, #0x98] // load gBS+0x98 (HandleProtocol) into x6
	ldr x3, [sp, #0x18]  //load ImageHandle from stack into x3 
	add x0, sp, #0x60	//move address of $sp+0x60 into x0
	mov x2, x0			//addr of $sp+0x60 (loadedImageProtocol*) into x2
	
	//add x1, sp, #38		//eh okay maybe load LIP GUID into x1?? Will this work
	//adrp x1, LoadedImageProtocolGuid
	//add x1, x1, :lo12: 	LoadedImageProtocolGuid		//#0x8

	//ldr x1, LoadedImageProtocolGuid
	ldr x0, [sp, #0x18] //load ImageHandle from stack into x0 
	blr x6
	str x0, [sp, #0xa8]	//save EFI_STATUS var to stack
	ldr x0, [sp, #0xa8]
	cmp x0, 0x0			//check if EFI_STATUS==EFI_SUCCESS (0x0)
//	b.eq Print
	b.ne Print

store_loadedimage_data:
	ldr	x0, [sp, #0x60]
	ldr x0, [x0, #0x18]		//deviceHandle = loadedImageProtocol->deviceHandle
	str x0, [sp, #0x70]		//store deviceHandle at [sp+ 0x70]
	ldr	x0, [sp, #0x60]
	ldr x0, [x0, #0x48]		//imgSize = loadedImageProtocol->imageSize
	str	x0, [sp, #0x68]		//store imgSize at [sp+ 0x68] 


get_sfsp:	
	//load Simple Filesystem Protocol guid
	mov w0, #0x5b22
	movk w0, #0x964e, LSL #16
	str w0, [sp,#0x50]  //Store first part of SFSP GUID at sp-0x50	
	mov w0, #0x6459
	strh w0, [sp, #0x54] //Store 2nd part of SFSP GUID at sp-0x54	
	mov w0, #0x11d2
	strh w0, [sp, #0x56] //Store 3rd part of SFSP GUID at sp-0x56	
	mov x0, #0x398e
	movk x0, #0xa000, LSL #16
	movk x0, #0x69c9, LSL #32
	movk x0, #0x3b72, LSL #48
	str x0, [sp, #0x58] //Store final part of SFSP GUID at sp-0x58	

	add x0, sp, #0x50	//move address of sp+50 to x0
	mov x1, x0			//address of $sp+0x50 (SFSP GUID) into x1
	
	ldr x0, [sp, #0xa0] //load x0 = gBS
	ldr x6, [x0, #0x98] // load gBS+0x98 (HandleProtocol) into x6
	ldr x3, [sp, #0x18]  //load ImageHandle from stack into x3 
	add x0, sp, #0x38	//move address of $sp+0x38 (sfsp) into x0
	mov x2, x0			//addr of $sp+0x38 (sfsp) into x2
	

	ldr x0, [sp, #0x70] //load DeviceHandle from stack into x0 
	blr x6
	str x0, [sp, #0xa8]	//save EFI_STATUS var to stack
	ldr x0, [sp, #0xa8]
	cmp x0, 0x0			//check if EFI_STATUS==EFI_SUCCESS (0x0)
	b.ne Print
	
get_root_volume:
	ldr x0, [sp, #0x38]	//load sfsp into x0
	ldr x6, [x0, #0x8]	//load sfsp+0x8 (sfsp->OpenVolume()) into x6
	add x2, sp, #0x80	//move address of $sp+0x80 (rootVolume) into x2
	mov x1, x2			//addr of $sp+0x80 (rootvolume) into x2
	blr x6
	str x0, [sp, #0xa8]	//save EFI_STATUS var to stack
	ldr x0, [sp, #0xa8]
	cmp x0, 0x0			//check if EFI_STATUS==EFI_SUCCESS (0x0)
	b.ne Print

open_host_file:
	ldr x0, [sp, #0x80]	//load EFI_FILE_PROTOCOL* rootvolume into x0
	ldr x6, [x0, #0x8]	//load rootvolume+0x8 (rootvolume->OpenFile()) into x6
	add x2, sp, #0x88	//move address of $sp+0x88 (hostfile) into x2
	mov x1, x2			//addr of $sp+0x88 (hostfile) into x1
	adrp x2, hostfilename
	add x2, x2, :lo12: hostfilename	//load address of hostfilename into x2	
	mov x3, #0x1
	blr x6
	str x0, [sp, #0xa8]	//save EFI_STATUS var to stack
	ldr x0, [sp, #0xa8]
	cmp x0, 0x0			//check if EFI_STATUS==EFI_SUCCESS (0x0)
	b.ne Print

open_target_file:
	ldr x0, [sp, #0x80]	//load EFI_FILE_PROTOCOL* rootvolume into x0
	ldr x6, [x0, #0x8]	//load rootvolume+0x8 (rootvolume->OpenFile()) into x6
	add x2, sp, #0x90	//move address of $sp+0x90 (targetfile) into x2
	mov x1, x2			//addr of $sp+0x90 (targetfile) into x1
	adrp x2, targetfilename
	add x2, x2, :lo12: targetfilename	//load address of hostfilename into x2	
	mov x3, #0x8000000000000003
	mov x4, #0x0
	blr x6
	str x0, [sp, #0xa8]	//save EFI_STATUS var to stack
	ldr x0, [sp, #0xa8]
	cmp x0, 0x0			//check if EFI_STATUS==EFI_SUCCESS (0x0)
	b.ne Print
	
allocate_tmp_buffer:

	ldr x0, [sp, #0xa0] //load x0 = gBS
	ldr x6, [x0, #0x40] // load gBS+0x40 (AllocatePool) into x6
	ldr x1, [sp, #0x68]		//load imagesize into x1
	add x0, sp, #0xb0	//move address of $sp+0xb0 (temp_buffer) into x0
	mov x2, x0			//addr of $sp+0xb0 (temp_buffer) into x2
	mov x0, #0x0 		//mov EFI_ALLOCATEPOOL_ALLOCATE_ANY_PAGES (0x0) into x0
	blr x6
	str x0, [sp, #0xa8]	//save EFI_STATUS var to stack
	ldr x0, [sp, #0xa8]
	cmp x0, 0x0			//check if EFI_STATUS==EFI_SUCCESS (0x0)
	b.ne Print

read_host_file:

	ldr x0, [sp, #0x88]	//load EFI_FILE_PROTOCOL* hostfile into x0
	ldr x6, [x0, #0x20]	//load hostfile+0x20 (hostfile->ReadFile()) into x6
	add x2, sp, #0x68	//move address of $sp+0x68 (imagesize) into x2
	mov x1, x2			//addr of $sp+0x68 (imagesize) into x1
	ldr x2, [sp, #0xb0]		//load temp_buffer into x1
	blr x6
	str x0, [sp, #0xa8]	//save EFI_STATUS var to stack
	ldr x0, [sp, #0xa8]
	cmp x0, 0x0			//check if EFI_STATUS==EFI_SUCCESS (0x0)
	b.ne Print

write_target_file:
	ldr x0, [sp, #0x90]	//load EFI_FILE_PROTOCOL* targetfile into x0
	ldr x6, [x0, #0x28]	//load targetfile+0x28 (targetfile->WriteFile()) into x6
	add x2, sp, #0x68	//move address of $sp+0x68 (imagesize) into x2
	mov x1, x2			//addr of $sp+0x68 (imagesize) into x1
	ldr x2, [sp, #0xb0]		//load temp_buffer into x1
	blr x6
	str x0, [sp, #0xa8]	//save EFI_STATUS var to stack
	ldr x0, [sp, #0xa8]
	cmp x0, 0x0			//check if EFI_STATUS==EFI_SUCCESS (0x0)
	b.ne Print
	b free_tmp_buffer

close_file:
	//ldr x0, [sp, #0x90]	//load EFI_FILE_PROTOCOL* targetfile into x0
	ldr x6, [x0, #0x10]	//load targetfile+0x10 (targetfile->CloseFile()) into x6
	blr x6
	str x0, [sp, #0xa8]	//save EFI_STATUS var to stack
	ldr x0, [sp, #0xa8]
	cmp x0, 0x0			//check if EFI_STATUS==EFI_SUCCESS (0x0)
	b.ne Print
	ret

free_tmp_buffer:
	//sub sp, sp, #0x10
	ldr x0, [sp, #0x90]	//load EFI_FILE_PROTOCOL* targetfile into x0
	ldr x6, [x0, #0x10]	//load targetfile+0x10 (targetfile->CloseFile()) into x6
	blr x6
	//bl close_file
	//add sp, sp, #0x10
	cmp x0, 0x0			//check if EFI_STATUS==EFI_SUCCESS (0x0)
	b.ne Print
	
	ldr x0, [sp, #0xa0] //load x0 = gBS
	ldr x6, [x0, #0x48] // load gBS+0x48 (FreePool) into x6
	ldr x0, [sp, #0xb0]	//move $sp+0xb0 (temp_buffer) into x0
	blr x6
	str x0, [sp, #0xa8]	//save EFI_STATUS var to stack
	ldr x0, [sp, #0xa8]
	cmp x0, 0x0			//check if EFI_STATUS==EFI_SUCCESS (0x0)
	b.ne Print
	
	
	//sub sp, sp, #0x10
	ldr x0, [sp, #0x88]	//load EFI_FILE_PROTOCOL* hostfile into x0
	ldr x6, [x0, #0x10]	//load targetfile+0x10 (targetfile->CloseFile()) into x6
	blr x6
	//bl close_file
	//add sp, sp, #0x10
	cmp x0, 0x0			//check if EFI_STATUS==EFI_SUCCESS (0x0)
	b.ne Print

	//sub sp, sp, #0x10
	ldr x0, [sp, #0x80]	//load EFI_FILE_PROTOCOL* rootvolume into x0
	ldr x6, [x0, #0x10]	//load targetfile+0x10 (targetfile->CloseFile()) into x6
	blr x6
	//bl close_file
	//add sp, sp, #0x10
	cmp x0, 0x0			//check if EFI_STATUS==EFI_SUCCESS (0x0)
	b.ne Print

	b exit

Print:
	ldr x1, [sp, #0x10] //load x0 = SystemTable (from stack at sp - #0x10)
	ldr x0, [x1, #0x40] //load x0 = ConOut (SystemTable + 0x40)
	ldr x3, [x0, #0x8] //load x3 =  OutputString = SystemTable->ConOut->OutputString== x0 + 0x8 == ConOut + 0x8 == OutputString
	ldr x0, [sp, #0x10] //load x0 = SystemTable (from stack at sp + #0x10)
	ldr x2, [x0, #0x40] //load x2 = ConOut == x0 + 0x40 = SystemTable + 0x40
	adr x1, .			//get address of $PC to calculate entry point addr for debugging
	
	ldr x0, [sp, #0x50]
	add x0, x0, #0x40
	str x0, [sp, #0x60]
	
	adrp x1, hellostr
	add x1, x1, :lo12: hellostr//	
	//add x1, x1, hellochars
	//add x1, x1, =hellostr
	//ldr x1, =hellostr
	//mov x1, #0x0048
	//movk x1, #0x0065, lsl #16
	//movk x1, #0x006c, lsl #32
	//movk x1, #0x006c, lsl #48
	//str x1, [sp, #0x58]
	//add x1, sp, #0x58
	mov x0, x2 //mov x0 = SystemTable->ConOut == x2
	blr x3	//call SystemTable->ConOut->OutputString(SystemTable->ConOut, L"hello from the other side\n");
	b exit
	//b .store_loadedimage_data
	
exit:
	//function epilogue
	mov x0, #0x0 //return 0
	//add sp, sp, #0xa0
	ldp x29, x30, [sp], #0xc0 //restore x29 and x30
	ret	

.data
.balign 8
hellostr:
	.string16 "Hello from the other side"

.balign 8
LoadedImageProtocolGuid:
	.word 0x5b1b31a1
	.hword 0x9562
	.hword 0x11d2
	.byte 0x3b, 0x72, 0x69, 0xc9, 0xa0, 0x00, 0x3f, 0x8e
	;.byte 0x83,0xe9,0x00,0xac,0x0c,0x96,0x97,0x23

hostfilename:
	.string16 "\\QuineArm64.efi\0"

targetfilename:
	.string16 "\\4.efi\0"
	//.word 0x00480065
	//.word 0x48, 0x00, 0x65, 0x00, 0x6C, 0x00, 0x6C, 0x00, 0x6F, 0x00, 0x20, 0x00, 0x66, 0x00, 0x72, 0x00, 0x6F, 0x00, 0x6D, 0x00, 0x20, 0x00, 0x74, 0x00, 0x68, 0x00, 0x65, 0x00, 0x20, 0x00, 0x6F, 0x00, 0x74, 0x00, 0x68, 0x00, 0x65, 0x00, 0x72, 0x00, 0x20, 0x00, 0x73, 0x00, 0x69, 0x00, 0x64, 0x00, 0x65, 0x00
