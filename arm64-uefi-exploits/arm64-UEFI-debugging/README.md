##Debugging instructions
This is going to be a nightmare so prepare yourself.
There are easier ways to do this (theoretically) but this is what worked for me to properly configure debugging for arm64 UEFI apps in gdb and QEMU. 

OVMF prints debug messages to a file called debug.log
This file contains lots of useful info, but for our purposes it has a treasure trove of addresses that we want:
debug.log is used to identify the load addresses of drivers/apps that you want to debug with GDB
The debug process for configuring GDB with OVMF is more than a little tedious
However the debugcon file saves us a lot of time, and eventually we can automate a lot of the setup
processing for an OVMF UEFI debugging session in QEMU using the info from the debug.log file
and writing some simple shell and Python scripts


For other architectures, the debugcon file is not necessarily supported
For ARM64/AArch64, it is not supported.



So we have to do the following:
- *Manually* find the load address of our target UEFI app/driver
- Then we use the gdb ```info files``` command to print the offset of the .text and .data sections
within our target bin
- Then we calculate the address of the .text section using our previously identified entry point + .text offset
- Then repeat the previous step, and do the same thing to calculate the address for the .data section (entry point + .data offset) 

The last three steps of that process are identical to UEFI debugging with OVMF and other x64 BIOS builds
But that first step...how the fuck do we manually find the load address? 

How do we find the load address of our program without debug output? 
How do we know where our UEFI app/driver will be loaded before it's loaded?
How can mirrors be real if our eyes aren't real??

We don't know where the UEFI app/driver will be loaded. 
We have to perform at least one trial run with an attached debugger before we have the load address

This is how we do that:

1. run the following command to launch qemu-system-aarch64 with the correct config:
	```qemu-system-aarch64 -M virt -cpu cortex-a57 -bios ./aarch64_uefi_test_env/QEMU_EFI_AA64.fd -m 1G -drive format=raw,file=fat:rw:UEFI_bb_disk -serial pty -monitor pty -serial file:./log.txt -nographic -net none```

2. We use this to do the following:
	- allocate a PTY for a serial console 
	- allocate a PTY for the qemu monitor
	For each PTY you allocate with this command, QEMU will print the path to each PTY to stdio when qemu-system-aarch64 is launched
	Connect to each PTY in a separate terminal window (i.e. you can use a tmux session w a split window for 2 PTYs) with the command  ```sudo screen /dev/pts/[#]``` 


3. Start gdb (or gdb-multiarch or aarch64-elf-gdb, depending on your machine's architecture and the version of gdb you installed for aarch64 debugging) with the following flags:
```ic3qu33n:~$aarch64-elf-gdb -q --nh -ex 'set architecture aarch64' -ex 'target remote :1234'  -ex 'layout regs' -ex 'layout split'```

Note: you likely won't need the first argument unless you're running gdb-multiarch. If you're running aarch64-elf-gdb, or you're running gdb on an aarch64 machine, then you should be fine with the auto detected architecture (which should be aarch64).

4. Open a new terminal window. Optionally, though highly recommended, start a tmux session and split the screen, then in each panel, connect to the two PTYs we allocated previously
5. In the qemu monitor panel, type the command `c`
6. In the serial console panel, hit the enter/return key. You should be greeted with the UEFI Shell like so:
```Shell> ````

7. In the qemu monitor, run the following:
```info registers```
```x/10i 0x{address of $PC from previous command output}
```c```
```info registers```
```x/10i 0x{address of $PC from previous command output}

Here, we are printing the initial state of the registers before running our UEFI app/loading our UEFI driver.
Then we run the app/load the driver
Then we print the registers again
This is pretty simple. It's tedious but it's simple.
So after we have performed our initial run/load of our UEFI app/driver, we'll know the value of the $PC (technically we'll have what we need even if the program crashed. If it ran without errors, then it's a bonus.) We'll print memory starting from the $PC address, then adjusting the address that we pass to the qemu monitor print command, depending on whther or not we find anything recognizable in the mem dump.



My process for debugging my UEFI aarch64 quine was thus:
- Run program (which crashed) and use $PC to print values
- The $PC was at 0x7bc17acc
I also had a debug output with the address where an exception occurred. This address proved to be more useful.
```Synchronous exception occurred at 0x78760bc8```
In qemu monitor:
```x/40i 0x78760b00```
The output for this memory dump showed me what I wanted: 
at offset 0x34 from the start of this memory dump (0x7876b34), there was the first instruction of the main function of my aarch64 assembly program
t fucking god.
At address 0x7876b00 was the dummy entry point that jumped to the first instruction in main
However knowing the addresses for both of these functions was critically important.

So I now knew the address of main. I could have stopped there but I wanted the UEFI debug symbols from my symbol file.
So I needed to compute the address of both the .text section and the .data section within the loaded UEFI app

I ran the following in gdb:
```file UEFI_bb_disk/UEFIQuineAarch64.efi```
```info files```
which returned the output:
```


```

The .text section was at offset 0x1000 from the start of the binary
the .data section was at offset 0x5000 from the start of the binary

And I knew the address of the main function.
So if I compute the offset of main from the start of the binary, 
then I'll know the starting address of the binary
And from there, I can just add the .text and .data offsets

I'm not proud of this next part but it was easy and it worked.
I opened Ghidra and opened the project file, and opened UEFIQuineAarch64.efi

UEFI is consistent at using static offsets for computing addresses (i.e. to the gBS and gRT from the gST)
The same logic can be applied here
If we find the offset of the main function from the start of the binary, 
then we'll know the offset of the main function of our UEFI bin that is loaded in QEMU

To test this out, I did the following:
- open the UEFIQuineAarch64.efi inary in Ghidra and run the 2 plugins
- go to the identified UefiMain function
- write down the address: in this case, UefiMain is at offset 0x3b34

So that means that the load address of our UEFI app should be:
[Addess found in qemu monitor mem dump] - [offset of main, from Ghidra]
0x78760b34 - 0x3b34 == 0x7875d000
Wow both these numbers end in 0xb34, that seems like a good indicator.

So using this base, we can compute our .text and .data section addresses
.text : 0x7875e000
.data : 0x78762000
Let's print the mem dump at the new address we just computed:

Those are the first instructions we see in the module EntryPoint in Ghidra, and I recognize 
them from the disassembly listings of objdump. Perfect, that's the .text address.

Let's repeat to confirm we have the correct address for the .data section:

And yes, this is the .data section!! I recognize those goddamn EFI_GUIDs anywhere
 

So now we have our final command that we'll pass to gdb



```
add-symbol-file ~/uefi_testing/edk2/Build/BareBonesPkg/DEBUG_GCC/Aarch64/UefiQuineAarch64.debug 0x7875e000 -s .data 0x78762000
```


Now we have our symbol file and can add breakpoints easily and debug this nightmare
k that's all for now
luv u so much
xoxo


 
