BITS 64

default rel

section .header

;********************************************************************************************
; Basic UEFI shellcode payload for x64
; written in x64 assembly
; by ic3qu33n
; 
; This simple UEFI shellcode prints the following string to the console in the UEFI Shell:
; 
; utf16__ string 'SMM Exploited!'
;
; It is provided as a template for building out more complex UEFI shellcode payloads
; Use the makefile in this repo to compile it
; 
;********************************************************************************************


START:
PE:
header_start:
mzheader:
	dw "MZ" 								;  DOS e_magic
	dw 0x100

pe_header:
	dd "PE"									;	uint32_t mMagic; // PE\0\0 or 0x00004550
	dw 0x8664								;	uint16_t mMachine;
	dw 3									;	uint16_t mNumberOfSections;
	dd 0x0									;	uint32_t mTimeDateStamp;
	dd 0x0									;	uint32_t mPointerToSymbolTable;
	dd 0x0									;	uint32_t mNumberOfSymbols;

	dw sectionHeader - opt_header	 		;	uint16_t mSizeOfOptionalHeader;
	dw 0x0206 								;	uint16_t mCharacteristics;
opt_header:
	dw 0x20B								;	uint16_t mMagic; // 0x010b - PE32, 0x020b - PE32+ (64 bit)
	db 0									;	uint8_t  mMajorLinkerVersion;
	db 0									;	uint8_t  mMinorLinkerVersion;
	dd _codeend - codestart					;	uint32_t mSizeOfCode;
	dd _dataend - _datastart				;	uint32_t mSizeOfInitializedData;
	dd 0									;	uint32_t mSizeOfUninitializedData;
					
	dd entrypoint - START					;	uint32_t mAddressOfEntryPoint;
	dd entrypoint - START					;	uint32_t mBaseOfCode;
	dq 0x0									;	uint32_t mImageBase;
	dd 0x4									;	uint32_t mSectionAlignment;
	dd 0x4									;	uint32_t mFileAlignment;

	dw 0									;	uint16_t mMajorOperatingSystemVersion;
	dw 0									;	uint16_t mMinorOperatingSystemVersion;
	dw 0									;	uint16_t mMajorImageVersion;
	dw 0									;	uint16_t mMinorImageVersion;

	dw 0									;	uint16_t mMajorSubsystemVersion;
	dw 0									;	uint16_t mMinorSubsystemVersion;  can be blank, still times 4 db 0
	dd 0									;	uint32_t mWin32VersionValue;

	dd end - START  						;	uint32_t mSizeOfImage;
	dd header_end - header_start			;	uint32_t mSizeOfHeaders;
	dd 0									;	uint32_t mCheckSum;
	dw 0xa									;	uint16_t mSubsystem;
	dw 0x0									;	uint16_t mDllCharacteristics;
	dq 0x0									;	uint32_t mSizeOfStackReserve;
	dq 0x0									;	uint32_t mSizeOfStackCommit;
	dq 0x0									;	uint32_t mSizeOfHeapReserve;
	dq 0x0									;	uint32_t mSizeOfHeapCommit;
	dd 0x0									;	uint32_t mLoaderFlags;
	dd 0x6									;	uint32_t mNumberOfRvaAndSizes;
datadirs:
	dq 0	
	dq 0	
	dq 0	
	dq 0	
	dq 0	
	dq 0	
optend:

SECTS:
sectionHeader:								;struct IMAGE_SECTION_HEADER { // size 40 bytes
	db ".text",0,0,0						;	char[8]  mName;
	dd _codeend - codestart					;	uint32_t mVirtualSize;
	dd _start - START						;	uint32_t mVirtualAddress;
	dd _codeend - codestart					;	uint32_t mSizeOfRawData;
	dd _start - START						;	uint32_t mPointerToRawData;
	dd 0									;	uint32_t mPointerToRelocations;
	dd 0									;	uint32_t mPointerToLinenumbers;
	dw 0									;	uint16_t mNumberOfRelocations;
	dw 0									;	uint16_t mNumberOfLinenumbers;
	dd 0x60500020							;	uint32_t mCharacteristics;
											;};
dataSectionHeader:							;struct IMAGE_SECTION_HEADER { // size 40 bytes
	db ".data",0,0,0						;	char[8]  mName;
	dd _dataend - _datastart				;	uint32_t mVirtualSize;
	dd _datastart - START					;	uint32_t mVirtualAddress;
	dd _dataend - _datastart				;	uint32_t mSizeOfRawData;
	dd _datastart - START					;	uint32_t mPointerToRawData;
	dd 0									;	uint32_t mPointerToRelocations;
	dd 0									;	uint32_t mPointerToLinenumbers;
	dw 0									;	uint16_t mNumberOfRelocations;
	dw 0									;	uint16_t mNumberOfLinenumbers;
	dd 0xD0000040							;	uint32_t mCharacteristics;
											;};
relocSectionHeader:							;struct IMAGE_SECTION_HEADER { // size 40 bytes
	db ".reloc",0,0,0						;	char[8]  mName;
	dd 0									;	uint32_t mVirtualSize;
	dd 0									;	uint32_t mVirtualAddress;
	dd 0									;	uint32_t mSizeOfRawData;
	dd 0									;	uint32_t mPointerToRawData;
	dd 0									;	uint32_t mPointerToRelocations;
	dd 0									;	uint32_t mPointerToLinenumbers;
	dw 0									;	uint16_t mNumberOfRelocations;
	dw 0									;	uint16_t mNumberOfLinenumbers;
	dd 0x00000000							;	uint32_t mCharacteristics;
											;};
	times 512-($-$$) db 0
header_end:	
	
section .text follows=.header

global _start

codestart:
	
_start:
entrypoint:
	push rsp
	push rbp
	push rax
	push rbx
	push rcx
	push rdx
	push rsi
	push rdi
	push r8
	push r9
	push r10
	push r11
	push r12
	push r13
	push r14
	push r15
	mov rbp, rsp
	sub rsp,0x200

	mov rcx, [rdx + 0x40] ; gST + 0x40 == ConOut
	;utf16__ string 'SMM Exploited!'
	; 5300 4d00 4d00 2000 4500 7800 7000 6c00
	;
	; correct format for __utf16__  strings:
	; 0x00{char_1}0x00{char_0}
	mov dword [rbp - 0x40],0x004d0053
	mov dword [rbp - 0x3c],0x0020004d
	mov dword [rbp - 0x38],0x00780045
	mov dword [rbp - 0x34],0x006c0070
	mov dword [rbp - 0x30],0x0069006f
	mov dword [rbp - 0x2c],0x00650074

	mov rax, 0x00d000a00210064
	mov [rbp - 0x28], rax
	lea rdx, [rbp-0x40]
	mov rax, [rcx + 0x8]
	call rax
	jmp exit


exit:
	add rsp, 0x200
	mov rsp, rbp
	pop r15
	pop r14
	pop r13
	pop r12
	pop r11
	pop r10
	pop r9
	pop r8
	pop rdi
	pop rsi
	pop rdx
	pop rcx
	pop rbx
	pop rax
	pop rbp
	pop rsp
	ret
  
;; PE might require 28 bytes of paddiing here to conform to the f*d spec 
;; 28 bytes isn't even nicely aligned along a 16byte boundary so idfk
;	align 8
cEnd:
	times 512-($-$$) db 0
_codeend:


section .data

_datastart:
	times 512-($-$$) db 0
_dataend:	

section .reloc follows=.data
;empty but needed for UEFI for some reason?

end:
